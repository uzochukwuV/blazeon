// TimeLockVault - Advanced time-locked vault with P2S covenant support
// BOUNTY TARGET: P2S Covenant (10M sats)
//
// Features:
// - Time-locked funds with configurable unlock block
// - Partial withdrawals with covenant to preserve remaining lock
// - Recovery key for emergencies
// - Lock extension capability
// - P2S output support for flexible spending conditions

pragma cashscript ^0.13.0;

contract TimeLockVault(
    bytes20 ownerPkh,           // Owner's public key hash
    bytes20 recoveryPkh,        // Recovery key hash for emergencies
    int unlockBlock,            // Block height when funds can be withdrawn
    int vestingAmount           // Amount that vests per period (0 = all at once)
) {
    // Full withdrawal - only after unlock time
    function withdraw(pubkey ownerPk, sig ownerSig) {
        // Verify owner identity
        require(hash160(ownerPk) == ownerPkh);
        require(checkSig(ownerSig, ownerPk));

        // Verify time lock has passed
        require(tx.time >= unlockBlock);
    }

    // Partial withdrawal with covenant - withdraw some, keep rest locked
    // This creates a P2S-style output back to the same contract
    function partialWithdraw(
        pubkey ownerPk,
        sig ownerSig,
        int withdrawAmount
    ) {
        // Verify owner identity
        require(hash160(ownerPk) == ownerPkh);
        require(checkSig(ownerSig, ownerPk));

        // Verify time lock has passed
        require(tx.time >= unlockBlock);

        // Verify withdrawal amount is valid
        require(withdrawAmount > 0);
        require(withdrawAmount <= tx.inputs[0].value);

        // Calculate remaining amount
        int remainingAmount = tx.inputs[0].value - withdrawAmount - 1000;

        // If significant amount remains, covenant to keep it locked
        if (remainingAmount > 546) {
            // Output 0: Remaining funds stay in same contract (P2S covenant)
            require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
            require(tx.outputs[0].value >= remainingAmount);

            // Output 1: Withdrawn amount to owner
            bytes25 ownerLockingBytecode = new LockingBytecodeP2PKH(ownerPkh);
            require(tx.outputs[1].lockingBytecode == ownerLockingBytecode);
            require(tx.outputs[1].value >= withdrawAmount - 500);
        } else {
            // Small remainder - just send everything to owner
            bytes25 ownerLockingBytecode = new LockingBytecodeP2PKH(ownerPkh);
            require(tx.outputs[0].lockingBytecode == ownerLockingBytecode);
        }
    }

    // Vesting withdrawal - withdraw only the vested amount
    // Demonstrates time-based P2S covenant for gradual release
    function vestingWithdraw(pubkey ownerPk, sig ownerSig) {
        // Verify owner identity
        require(hash160(ownerPk) == ownerPkh);
        require(checkSig(ownerSig, ownerPk));

        // Must be after unlock time for any vesting
        require(tx.time >= unlockBlock);

        // Can only use this function if vestingAmount is set
        require(vestingAmount > 0);

        // Withdraw exactly the vesting amount
        int currentValue = tx.inputs[0].value;
        int toWithdraw = vestingAmount;

        // Don't withdraw more than available
        if (toWithdraw > currentValue - 546) {
            toWithdraw = currentValue - 546;
        }

        int remaining = currentValue - toWithdraw - 500;

        // Covenant: remaining stays locked, vested goes to owner
        if (remaining > 546) {
            // Output 0: Remaining stays in contract
            require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
            require(tx.outputs[0].value >= remaining);

            // Output 1: Vested amount to owner
            bytes25 ownerLockingBytecode = new LockingBytecodeP2PKH(ownerPkh);
            require(tx.outputs[1].lockingBytecode == ownerLockingBytecode);
        } else {
            // Final withdrawal
            bytes25 ownerLockingBytecode = new LockingBytecodeP2PKH(ownerPkh);
            require(tx.outputs[0].lockingBytecode == ownerLockingBytecode);
        }
    }

    // Emergency withdrawal - requires recovery key (no time restriction)
    function emergencyWithdraw(pubkey recoveryPk, sig recoverySig) {
        // Verify recovery key identity
        require(hash160(recoveryPk) == recoveryPkh);
        require(checkSig(recoverySig, recoveryPk));
    }

    // Extend the lock period - owner can delay withdrawal
    function extendLock(
        pubkey ownerPk,
        sig ownerSig,
        int newUnlockBlock
    ) {
        // Verify owner identity
        require(hash160(ownerPk) == ownerPkh);
        require(checkSig(ownerSig, ownerPk));

        // New unlock time must be later than current
        require(newUnlockBlock > unlockBlock);

        // Covenant: output must go back to contract with extended lock
        // Value must be preserved (minus small fee)
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(tx.outputs[0].value >= tx.inputs[0].value - 1000);
    }

    // Add more funds to the vault (anyone can deposit)
    function deposit() {
        // Output must go back to this contract with increased value
        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);
        require(tx.outputs[0].value > tx.inputs[0].value);
    }

    // Transfer ownership - current owner transfers to new owner
    function transferOwnership(
        pubkey ownerPk,
        sig ownerSig,
        bytes20 newOwnerPkh
    ) {
        // Verify current owner
        require(hash160(ownerPk) == ownerPkh);
        require(checkSig(ownerSig, ownerPk));

        // New owner must be different
        require(newOwnerPkh != ownerPkh);

        // Value must be preserved
        require(tx.outputs[0].value >= tx.inputs[0].value - 1000);
    }
}
